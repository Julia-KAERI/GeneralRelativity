<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>1&nbsp; 상대성 원리 – 일반상대성이론과 우주론</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../references.html" rel="next">
<link href="../../src/ClassicalFieldTheory/00_index.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-3e2728906df7980cb53b491a61d13d7e.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../src/ClassicalFieldTheory/00_index.html">고전 장론</a></li><li class="breadcrumb-item"><a href="../../src/ClassicalFieldTheory/01_principle_of_relativity.html"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">상대성 원리</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../src/ClassicalFieldTheory/00_index.html">고전 장론</a></li><li class="breadcrumb-item"><a href="../../src/ClassicalFieldTheory/01_principle_of_relativity.html"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">상대성 원리</span></a></li></ol></nav>
      <h1 class="title"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">상대성 원리</span></h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="../../index.html" class="sidebar-logo-link">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">일반상대성이론과 우주론</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../src/ClassicalFieldTheory/00_index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">고전 장론</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../src/ClassicalFieldTheory/01_principle_of_relativity.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">상대성 원리</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#상호작용의-전파-속도" id="toc-상호작용의-전파-속도" class="nav-link active" data-scroll-target="#상호작용의-전파-속도"><span class="header-section-number">1.1</span> 상호작용의 전파 속도</a>
  <ul class="collapse">
  <li><a href="#sec-CFT_background_knowledge" id="toc-sec-CFT_background_knowledge" class="nav-link" data-scroll-target="#sec-CFT_background_knowledge"><span class="header-section-number">1.1.1</span> 배경 지식</a></li>
  <li><a href="#sec-CFT_speed_of_light" id="toc-sec-CFT_speed_of_light" class="nav-link" data-scroll-target="#sec-CFT_speed_of_light"><span class="header-section-number">1.1.2</span> 빛의 속도</a></li>
  <li><a href="#sec-CFT_einstein_principle_of_relativity" id="toc-sec-CFT_einstein_principle_of_relativity" class="nav-link" data-scroll-target="#sec-CFT_einstein_principle_of_relativity"><span class="header-section-number">1.1.3</span> 상대성 이론</a></li>
  </ul></li>
  <li><a href="#sec-CFT_interval" id="toc-sec-CFT_interval" class="nav-link" data-scroll-target="#sec-CFT_interval"><span class="header-section-number">1.2</span> 4차원 시공간과 간격</a>
  <ul class="collapse">
  <li><a href="#sec-CFT_spacetime_event_worldline" id="toc-sec-CFT_spacetime_event_worldline" class="nav-link" data-scroll-target="#sec-CFT_spacetime_event_worldline"><span class="header-section-number">1.2.1</span> 4차원 시공간, 사건, 세계선</a></li>
  <li><a href="#sec-CFT_mathematical_form_of_constant_c" id="toc-sec-CFT_mathematical_form_of_constant_c" class="nav-link" data-scroll-target="#sec-CFT_mathematical_form_of_constant_c"><span class="header-section-number">1.2.2</span> 광속 불변의 수학적 형식</a></li>
  <li><a href="#sec-CFT_space_time_with_invariant_c" id="toc-sec-CFT_space_time_with_invariant_c" class="nav-link" data-scroll-target="#sec-CFT_space_time_with_invariant_c"><span class="header-section-number">1.2.3</span> 시간꼴 간격과 공간꼴 간격</a></li>
  </ul></li>
  <li><a href="#고유-시간" id="toc-고유-시간" class="nav-link" data-scroll-target="#고유-시간"><span class="header-section-number">1.3</span> 고유 시간</a>
  <ul class="collapse">
  <li><a href="#sec-CFT_proper_time" id="toc-sec-CFT_proper_time" class="nav-link" data-scroll-target="#sec-CFT_proper_time"><span class="header-section-number">1.3.1</span> 고유 시간</a></li>
  <li><a href="#sec-CFT_proper_time_in_different_frame" id="toc-sec-CFT_proper_time_in_different_frame" class="nav-link" data-scroll-target="#sec-CFT_proper_time_in_different_frame"><span class="header-section-number">1.3.2</span> 두 좌표계의 고유시간</a></li>
  </ul></li>
  <li><a href="#로런츠-변환" id="toc-로런츠-변환" class="nav-link" data-scroll-target="#로런츠-변환"><span class="header-section-number">1.4</span> 로런츠 변환</a>
  <ul class="collapse">
  <li><a href="#sec-CFT-lorentz_transform_in_1d_space" id="toc-sec-CFT-lorentz_transform_in_1d_space" class="nav-link" data-scroll-target="#sec-CFT-lorentz_transform_in_1d_space"><span class="header-section-number">1.4.1</span> 1차원 공간에서의 로런츠 변환</a></li>
  <li><a href="#sec-CFT_proper_length_and_lorentz_contraction" id="toc-sec-CFT_proper_length_and_lorentz_contraction" class="nav-link" data-scroll-target="#sec-CFT_proper_length_and_lorentz_contraction"><span class="header-section-number">1.4.2</span> 고유길이와 로런츠 수축</a></li>
  <li><a href="#sec-CFT_proper_time_by_lorentz_transform" id="toc-sec-CFT_proper_time_by_lorentz_transform" class="nav-link" data-scroll-target="#sec-CFT_proper_time_by_lorentz_transform"><span class="header-section-number">1.4.3</span> 로런츠 변환으로 본 고유시간</a></li>
  <li><a href="#sec-CFT_lorentz_tranfrom_of_velocity" id="toc-sec-CFT_lorentz_tranfrom_of_velocity" class="nav-link" data-scroll-target="#sec-CFT_lorentz_tranfrom_of_velocity"><span class="header-section-number">1.4.4</span> 속도의 로런츠 변환</a></li>
  </ul></li>
  <li><a href="#수학적-기초" id="toc-수학적-기초" class="nav-link" data-scroll-target="#수학적-기초"><span class="header-section-number">1.5</span> 수학적 기초</a>
  <ul class="collapse">
  <li><a href="#sec-CFT_contravariant_covariant_einstein" id="toc-sec-CFT_contravariant_covariant_einstein" class="nav-link" data-scroll-target="#sec-CFT_contravariant_covariant_einstein"><span class="header-section-number">1.5.1</span> 공변벡터, 반변벡터, 아인슈타인 표기법</a></li>
  <li><a href="#sec-CFT_rule_of_transformation" id="toc-sec-CFT_rule_of_transformation" class="nav-link" data-scroll-target="#sec-CFT_rule_of_transformation"><span class="header-section-number">1.5.2</span> 변환의 규칙</a></li>
  <li><a href="#텐서" id="toc-텐서" class="nav-link" data-scroll-target="#텐서"><span class="header-section-number">1.5.3</span> 텐서</a></li>
  </ul></li>
  <li><a href="#벡터" id="toc-벡터" class="nav-link" data-scroll-target="#벡터"><span class="header-section-number">1.6</span> 4-벡터</a>
  <ul class="collapse">
  <li><a href="#sec-CFT_4_vector" id="toc-sec-CFT_4_vector" class="nav-link" data-scroll-target="#sec-CFT_4_vector"><span class="header-section-number">1.6.1</span> 4-벡터와 4-스칼라</a></li>
  <li><a href="#sec-CFT_4_tensor" id="toc-sec-CFT_4_tensor" class="nav-link" data-scroll-target="#sec-CFT_4_tensor"><span class="header-section-number">1.6.2</span> 4-텐서</a></li>
  <li><a href="#sec-CFT_psedoscala_and_pseudo_vector" id="toc-sec-CFT_psedoscala_and_pseudo_vector" class="nav-link" data-scroll-target="#sec-CFT_psedoscala_and_pseudo_vector"><span class="header-section-number">1.6.3</span> 유사스칼라와 유사벡터</a></li>
  <li><a href="#sec-CFT_dual_tensor" id="toc-sec-CFT_dual_tensor" class="nav-link" data-scroll-target="#sec-CFT_dual_tensor"><span class="header-section-number">1.6.4</span> 쌍대 텐서</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<div class="hidden">
<p>% %</p>
%
<p><span class="math display">\[
\DeclarePairedDelimiters{\set}{\{}{\}}
\DeclareMathOperator*{\argmax}{argmax}
\]</span></p>
</div>
<section id="상호작용의-전파-속도" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="상호작용의-전파-속도"><span class="header-section-number">1.1</span> 상호작용의 전파 속도</h2>
<section id="sec-CFT_background_knowledge" class="level3" data-number="1.1.1">
<h3 data-number="1.1.1" class="anchored" data-anchor-id="sec-CFT_background_knowledge"><span class="header-section-number">1.1.1</span> 배경 지식</h3>
<ul>
<li><p><strong>기준틀</strong> (<em>system of reference</em>)</p>
<ul>
<li>좌표계 (system of coordinate) : 공간상의 입자의 위치</li>
<li>좌표계의 고유한 시계</li>
</ul></li>
<li><p><strong>관성좌표계</strong> (<em>inertial frame of reference</em>) : 외부로부터 힘을 받지 않는 물체는 등속으로 운동을 하는 기준틀.</p></li>
<li><p>두 기준틀이 서로 등속 운동을 할 때 한 기준틀이 관성좌표계이면 다른 좌표계 역시 관성좌표계이다.</p></li>
<li><p>상대성 원리 (<em>principle of relativity</em>): 자연법칙은 모든 관성좌표계에서 동일하다. 즉 운동방정식은 모든 관성좌표계에서 동일하다.</p></li>
</ul>
<p><br></p>
</section>
<section id="sec-CFT_speed_of_light" class="level3" data-number="1.1.2">
<h3 data-number="1.1.2" class="anchored" data-anchor-id="sec-CFT_speed_of_light"><span class="header-section-number">1.1.2</span> 빛의 속도</h3>
<ul>
<li>고전역학에서 물질의 입자간 상호작용은 입자의 위치의 함수인 포텐셜 에너지로 기술된다. 이것은 상호작용의 전달 속도가 무한대임을 의미한다. 즉 상호작용하는 입자의 위치가 변경될 경우 그 영향은 즉각 반영된다. 그러나 실험은 이런 즉각적인 상호작용은 자연에서 존재하지 않음을 보였다.</li>
<li>어느 정도 떨어진 두 입자에서 한 입자에 변화가 있을 때 다른 입자가 그 영향을 느끼는 시간차와 두 입자 사이의 거리를 통해 상호작용의 전달 속도(<em>velocity of propagation of the interaction</em>)를 측정 할 수 있다.</li>
<li>엄밀하게 말하면 앞의 속도는 상호작용의 최대전달속도(<em>maximum velocity of propagation of interaction</em>) 이다.</li>
<li>물체의 속도가 이 속도보다 크다면 상호작용이 전달되지 않는다. 따라서 물체의 속도가 이 상호작용의 최대전달속도보다 클 수 없다.</li>
<li>한 입자에서 다른 입자로의 상호작용의 전달을 <strong>신호</strong> (<em>signal</em>) 라고 한다. 상호작용의 전달속도를 신호 속도(<em>signal velocity</em>) 라고 한다.</li>
<li>상대성 원리는 모든 상호작용의 전달속도는 관성좌표계에서 일정함을 가정한다. 즉 이 신호 전달속도는 우주상수이다. 상호작용의 전달속도는 빛의 속도 <span class="math inline">\(c\)</span> 이다.</li>
</ul>
<p><span class="math display">\[
c=2.99792458 \times 10^8 \text{ m}/\text{sec}
\]</span></p>
<p><br></p>
</section>
<section id="sec-CFT_einstein_principle_of_relativity" class="level3" data-number="1.1.3">
<h3 data-number="1.1.3" class="anchored" data-anchor-id="sec-CFT_einstein_principle_of_relativity"><span class="header-section-number">1.1.3</span> 상대성 이론</h3>
<ul>
<li>아인슈타인의 상대성 원리는 두 원리의 결합이다.
<ol type="1">
<li>상대성 원리.</li>
<li>상호작용의 전달속도의 보편성.</li>
</ol></li>
<li>뉴턴 역학, 즉 고전역학은 상대성 원리의 <span class="math inline">\(c\to \infty\)</span> 극한이다.</li>
</ul>
<p><br></p>
<section id="고전역학에서의-시간과-공간-그리고-동시성" class="level4">
<h4 class="anchored" data-anchor-id="고전역학에서의-시간과-공간-그리고-동시성"><strong>고전역학에서의 시간과 공간 그리고 동시성</strong></h4>
<p>공간상의 거리는 고전역학에서도 상대적이다. 한 관성좌표계에서 정지해 있는 물체는 다른 관성좌표계에서는 일정한 속도로 이동한다. 그러나 시간은 고전역학에서 절대적이다. 모든 관성좌표계가 동일한 시계를 공유한다. 즉 한 기준틀에서 같은 시간에 일어난 두 사건은 다른 기준틀에서도 동시에 일어난다. 또한 동시에 일어나지 않은 두 사건의 시간간격은 모든 기준틀에서 동일하다.</p>
<p>그러나 이것은 상대성 이론에 어긋나는데 한 좌표계에서의 빛의 속도는 이 좌표계에 대해 <span class="math inline">\(v\)</span> 의 속도로 움직이는 좌표계에서 <span class="math inline">\(c+v &gt;c\)</span> 가 될 수 있기 때문이다.</p>
<p>마이켈슨의 실험에서 빛의 속도는 방향과 무관하게 동일하다는 것을 보였다. 그러나 고전역학에 따르면 빛의 속도는 지구의 진행방향에서 가장 작아야 한다.</p>
<p>두 관성좌표계 <span class="math inline">\(\Sigma,\,\Sigma'\)</span> 을 생각하자. <span class="math inline">\(\Sigma\)</span> 의 좌표축 <span class="math inline">\(x,\,y,\,z\)</span> 와 <span class="math inline">\(\Sigma'\)</span> 의 좌표축 <span class="math inline">\(x',\,y',\,z'\)</span> 을 생각하자. <span class="math inline">\(\Sigma'\)</span> 은 <span class="math inline">\(\Sigma\)</span> 에 대해 <span class="math inline">\(x(x')\)</span> 방향으로 움직인다고 하자. <span class="math inline">\(x'\)</span> 축상의 점 <span class="math inline">\(A\)</span> 에 대해 같은 거리, 반대 방향으로 역시 <span class="math inline">\(x'\)</span> 축 상에 <span class="math inline">\(B,\,C\)</span> 를 놓자. <span class="math inline">\(A\)</span> 에서 동시에 <span class="math inline">\(B,\,C\)</span> 방향으로 빛을 쏜다면 <span class="math inline">\(\Sigma'\)</span> 에서는 동시에 <span class="math inline">\(B,\,C\)</span> 에 도달한다. 그러나 밫의 속도가 일정하다는 것을 가정하면 <span class="math inline">\(\Sigma\)</span> 기준틀에서는 서로 다른 시간에 도착한다.</p>
<p><br></p>
</section>
</section>
</section>
<section id="sec-CFT_interval" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="sec-CFT_interval"><span class="header-section-number">1.2</span> 4차원 시공간과 간격</h2>
<section id="sec-CFT_spacetime_event_worldline" class="level3" data-number="1.2.1">
<h3 data-number="1.2.1" class="anchored" data-anchor-id="sec-CFT_spacetime_event_worldline"><span class="header-section-number">1.2.1</span> 4차원 시공간, 사건, 세계선</h3>
<p>3차원 공간과 1차원의 시간을 합쳐 4차원 시공간을 생각 할 수 있다. 물리적으로 어떤 <strong>사건</strong>(<em>event</em>) 가 벌여졌을 때 이 사건의 공간과 시간상의 좌표는 이 4차원 시공간상의 한 점이다. 이 점을 <strong>세계점</strong>(<em>world point</em>) 라고 한다. 입자의 운동은 이 4차원 시공간상에서 궤적을 갖는데 이 궤적을 <strong>세계선</strong>(<em>world line</em>) 이라고 한다. 기준틀에서 등속 운동을 하는 입자의 세계선은 직선이다.</p>
<p><br></p>
</section>
<section id="sec-CFT_mathematical_form_of_constant_c" class="level3" data-number="1.2.2">
<h3 data-number="1.2.2" class="anchored" data-anchor-id="sec-CFT_mathematical_form_of_constant_c"><span class="header-section-number">1.2.2</span> 광속 불변의 수학적 형식</h3>
<p>좌표계를 확장하여 4차원 시공간에서 기술한다. 두 좌표계 <span class="math inline">\(\Sigma (t,\,x,\,y,\,z,),\, \Sigma' (t',\,x',\,y',\,z')\)</span> 을 생각하자. 이 때 <span class="math inline">\(y\)</span> 와 <span class="math inline">\(y'\)</span>, 그리고 <span class="math inline">\(z,\, z'\)</span> 은 서로 평행하다고 하자. 그리고 각각의 좌표를 <span class="math inline">\((t,\,x,\,y,\,z),\, (t',\,x',\,y',\,z')\)</span> 혹은 <span class="math inline">\((t,\,\boldsymbol{x}),\, (t',\,\boldsymbol{x}')\)</span> 로 표기하자. <span class="math inline">\(\Sigma\)</span> 좌표계에서 두 사건에 대해 <strong>시공간 간격</strong>(<em>spacetime interval</em>) <span class="math inline">\(\Delta s\)</span> 은 아래와 같이 정의된다.</p>
<p><span id="eq-CFT_definition_of_interval"><span class="math display">\[
(\Delta s) := \sqrt{c^2(\Delta t)^2-(\Delta x)^2 - (\Delta y)^2 - (\Delta z)^2}.
\tag{1.1}\]</span></span></p>
<p>같은 방법으로 <span class="math inline">\(\Sigma'\)</span> 에서의 두 사건의 간격 <span class="math inline">\(\Delta s'\)</span> 을 정의 할 수 있다. 이 이벤트가 상호작용의 신호가 전달되는 사건이라고 하자. 신호 전달은 빛의 속도 <span class="math inline">\(c\)</span> 로 이루어지므로 <span class="math inline">\(\Delta s = \Delta s' = 0\)</span> 이어야 한다.</p>
<p>이 두 사건이 시공간에서의 미소한 차이에서 벌여졌을 때 아래와 같이 쓸 수 있다.</p>
<p><span id="eq-CFT_interval_between_infinitesimal_difference_in_spacetime"><span class="math display">\[
ds^2 = c^2dt^2 -dx^2-dy^2 - dz^2
\tag{1.2}\]</span></span></p>
<p><a href="#eq-CFT_definition_of_interval" class="quarto-xref">식&nbsp;<span>1.1</span></a> 와 <a href="#eq-CFT_interval_between_infinitesimal_difference_in_spacetime" class="quarto-xref">식&nbsp;<span>1.2</span></a> 는 간격이 4차원 시공간상의 일종의 거리라고 볼 수 있다는 것을 말한다. 그 축은 <span class="math inline">\(x,\,y,\,z,\,ct\)</span> 이다. 우리는 한 관성좌표계에서 간격이 <span class="math inline">\(0\)</span> 이면 다른 관성좌표계에서도 간격이 <span class="math inline">\(0\)</span> 임을 안다. 또한 <span class="math inline">\(ds\)</span> 와 <span class="math inline">\(ds'\)</span> 은 같은 차수의 미소변량이므로 서로 비례해야만 한다. 즉</p>
<p><span class="math display">\[
ds^2 = a \cdot ds'^2
\]</span></p>
<p>이다. 여기서 <span class="math inline">\(a\)</span> 는 4차원 시공간의 특정 좌표에 무관해야 하며, 두 좌표계 사이의 상대속도의 방향에 무관해야 한다. 이것은 시간과 공간의 homogeneity 와 공간의 isotropy 로부터의 결론이다. 이 성질은 고전역학 뿐만 아니라 상대성 이론에서도 역시 일하게 가정된다. 그렇다면 <span class="math inline">\(a\)</span> 는 두 좌표계의 상대 속도의 크기에만 의존해야 한다.</p>
<p>세 좌표계 <span class="math inline">\(\Sigma,\, \Sigma_1,\, \Sigma_2\)</span> 를 생각하자. 그리고 <span class="math inline">\(\Sigma_1\)</span> 과 <span class="math inline">\(\Sigma_2\)</span> 는 <span class="math inline">\(\Sigma\)</span> 에 대해 각각 <span class="math inline">\(\boldsymbol{V}_1,\,\boldsymbol{V}_2\)</span> 의 속도로 움직인다고 하자. 그리고 <span class="math inline">\(\Sigma_1,\,\Sigma_2\)</span> 사이의 상대속의 크기가 <span class="math inline">\(\boldsymbol{V}_{12}\)</span> 라고 하자. 그렇다면</p>
<p><span class="math display">\[
ds^2 = a(V_1)\,ds_1^2,\qquad ds^2 = a(V_2)\,ds_2^2, \qquad ds_1^2 = a(V_{12})\,ds_2^2
\]</span></p>
<p>이 세 식을 비교하면</p>
<p><span class="math display">\[
\dfrac{a(V_2)}{a(V_1)}= a(V_{12})
\]</span></p>
<p>를 얻는다. 그런데 <span class="math inline">\(V_{12}\)</span> 는 <span class="math inline">\(\boldsymbol{V}_1,\,\boldsymbol{V}_2\)</span> 의 크기 뿐만 아니라 방향에도 의존하지만 위의 식에는 방향의존성이 없다. 즉 <span class="math inline">\(a(V)\)</span> 는 상수함수이며 위의 식으로부터 <span class="math inline">\(a(V)=1\)</span> 일 수 밖에 없다. 즉 간격은 시공간 좌표 변환에 대해 불변이다.</p>
<p><span id="eq-CFT_invariance_of_interval"><span class="math display">\[
ds^2 = ds'^2
\tag{1.3}\]</span></span></p>
<p><br></p>
</section>
<section id="sec-CFT_space_time_with_invariant_c" class="level3" data-number="1.2.3">
<h3 data-number="1.2.3" class="anchored" data-anchor-id="sec-CFT_space_time_with_invariant_c"><span class="header-section-number">1.2.3</span> 시간꼴 간격과 공간꼴 간격</h3>
<p>한 기준틀 <span class="math inline">\(\Sigma\)</span> 에서의 두 사건 <span class="math inline">\((t_1,\, \boldsymbol{x}_1)\)</span>, <span class="math inline">\((t_2,\,\boldsymbol{x}_2)\)</span> 이 다른 기준틀에서 같은 위치 혹은 같은 시간에서 발생할 수 있을까? 우선 위치의 경우를 살펴보자. <span class="math inline">\(\Sigma\)</span> 에서의 간격 <span class="math inline">\((\Delta s)^2 = c^2(\Delta t)^2 - \|\Delta \boldsymbol{x}\|^2\)</span> 과 다른 기준틀 <span class="math inline">\(\Sigma'\)</span> 에서의 간격 <span class="math inline">\((\Delta s')^2 = c^2(\Delta t')^2 - \|\Delta \boldsymbol{x}'\|^2\)</span> 을 생각하자. <span class="math inline">\(\Sigma'\)</span> 에서 같은 위치에서 두 사건이 발생했다면 <span class="math inline">\(\Delta \boldsymbol{x}'=0\)</span> 이므로 <span class="math inline">\((\Delta s')^2 &gt;0\)</span> 이다. 그렇다면 <span class="math inline">\((\Delta s)^2 &gt; 0\)</span> 이어야 하며 이렇게 두 사건 사이의 간격이 실수인 경우 두 사건의 시공간 간격을 <strong>시간꼴 간격</strong> (<em>timelike interval</em>) 이라고 한다. 즉 두 사건의 간격이 시간꼴이라면 두 사건이 같은 위치에서 발생하는 기준틀이 존재한다. 그리고 이 경우 <span class="math inline">\(\Delta t'\)</span> 은 아래와 같다.</p>
<p><span class="math display">\[
\Delta t' = \dfrac{\Delta s'}{c} = \dfrac{\Delta s}{c} = \dfrac{\sqrt{c^2(\Delta t)^2 - \|\Delta \boldsymbol{x}\|^2}}{c}.
\]</span></p>
<p>한 물체에서 벌어진 두 사건은 항상 시간꼴이다. 이 물체는 빛보다 빠를 수 없기 때문이다.</p>
<p>이제 기준틀 <span class="math inline">\(\Sigma\)</span> 에서의 두 사건이 다른 기준틀에서 같은 시간에 발생하는 경우를 살펴 보자. <span class="math inline">\(\Delta t' = 0\)</span> 이라면 <span class="math inline">\(\Delta s'\)</span> 은 허수이며 <span class="math inline">\(\Delta s\)</span> 역시 그러해야 한다. 이런 시공간 간격을 <strong>공간꼴 간격</strong> (<em>spacelike interval</em>) 이라고 하며 이 경우 <span class="math inline">\(\|\Delta \boldsymbol{x}\|\)</span> 는 다음과 같다,.</p>
<p><span class="math display">\[
\|\Delta \boldsymbol{x}'\| = i\Delta s' = i \Delta s = i\sqrt{c^2(\Delta t)^2 - \|\Delta \boldsymbol{x}\|^2}.
\]</span></p>
<p><br></p>
<p>어떤 사건이 한 기준틀의 원점 <span class="math inline">\(\mathcal{O}\)</span> 에서 발생했다고 하자. 그리고 이 기준틀에서 다른 이벤트와의 관계를 알아보기 위해 아래 <a href="#fig-CFT_spacetime0" class="quarto-xref">그림&nbsp;<span>1.1</span></a> 와 같이 도식화 해 보자. 여기서는 공간을 <span class="math inline">\(x\)</span> 축에서만 생각한다. 원점을 지나는 등속운동은 아래 그림에서 원점을 지나는 직선으로 표현된다. 가능한 최대 속도가 <span class="math inline">\(c\)</span> 로 제한되어 있으므로 이 직선이 <span class="math inline">\(t\)</span> 축과 이루는 각의 최대값은 정해져 있다. 아래 그림에서는 빛의 세계선을 각각 <span class="math inline">\(\rm{a},\,\rm{b},\,\rm{c},\,\rm{d}\)</span> 로 표기하였다.</p>
<div id="fig-CFT_spacetime0" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-CFT_spacetime0-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/spacetime0.png" class="img-fluid figure-img" width="300">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-CFT_spacetime0-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;1.1: <span class="math inline">\(\mathcal{O}\)</span> 에서 발생한 사건의 시공간적 분리
</figcaption>
</figure>
</div>
<p><span class="math inline">\(a\mathcal{O}c\)</span> 영역에서의 사건 <span class="math inline">\((t,\,\boldsymbol{x})\)</span> 를 생각하자. 여기서는 <span class="math inline">\(c^2t^2-x^2&gt;0\)</span> 이므로 시간꼴 간격이며, <span class="math inline">\(t&gt;0\)</span> 이므로 여기서의 사건은 항상 원점에서의 사건 이후에 발생한 사건이다. 이 영역에서 발생한 두 사건은 다른 기준틀에서 동시에 발생 할 수 없으며 모든 기준틀에서 원점에서의 사건 이후에 발생한다. 따라서 이 영역은 원점에서의 사건에 대해 절대적인 미래(absolute future) 이다. 같은 방법으로 <span class="math inline">\(b\mathcal{O}d\)</span> 영역의 사건은 원점에서의 사건에 대해 절대적인 과거(absolute past) 이다.</p>
<p>이제 <span class="math inline">\(d\mathcal{O}a\)</span> 영역 혹은 <span class="math inline">\(b\mathcal{O}c\)</span> 영역에서 발생한 사건에 대해 생각해보자. 원점에서의 사건과 이 사건은 공간꼴 간격을 가지며 따라서 어떤 기준틀에서도 같은 위치에서 발생 할 수 없다. 즉 이 두 사건은 절대적으로 분리되어 있다(<em>be absolutely separated</em>). 그러나 시간적 선후관계는 기준틀마다 바뀔 수 있다.</p>
<p>1차원 공간이 아니라 다차원 공간을 생각하면 시간꼴 간격과 공간꼴 간격을 분리하는 것은 원뿔이며 이 원뿔을 <strong>광추</strong>(<em>light cone</em>) 라고 한다.</p>
<div id="fig-CFT_lightcone" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-CFT_lightcone-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="https://upload.wikimedia.org/wikipedia/commons/9/9a/World_line.png" class="img-fluid figure-img" width="250">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-CFT_lightcone-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;1.2: 2D 공간과 시간 차원의 광추 (from Wikipedia)
</figcaption>
</figure>
</div>
<p>두 사건의 시공간 간격이 시간꼴이면 서로 원인과 결과로 묶일 수 있다. 그러나 공간꼴이면 그렇지 않다.</p>
<p><br></p>
</section>
</section>
<section id="고유-시간" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="고유-시간"><span class="header-section-number">1.3</span> 고유 시간</h2>
<section id="sec-CFT_proper_time" class="level3" data-number="1.3.1">
<h3 data-number="1.3.1" class="anchored" data-anchor-id="sec-CFT_proper_time"><span class="header-section-number">1.3.1</span> 고유 시간</h3>
<p>어떤 기준틀 <span class="math inline">\(\Sigma\)</span> 에서 자유롭게 움직이는 시계를 관찰한다고 생각해보자. 각각의 시간마다 이 움직임은 국소적으로 등속운동으로 생각 할 수 있으며, 따라서 각 순간마다 움직이는 시계에 고정된 관성 기준틀을 생각 할 수 있다. 즉 <span class="math inline">\(dt\)</span> 의 시간 간격에 <span class="math inline">\(\|d\boldsymbol{x}\|^2\)</span> 만큼의 거리를 움직인다고 생각 할 수 있다. 시계에 고정된 기준틀 <span class="math inline">\(\Sigma'\)</span> 에서는 <span class="math inline">\(d\boldsymbol{x}=0\)</span> 이므로 시공간 간격의 불변을 생각하면</p>
<p><span class="math display">\[
c^2 dt^2 - \|d\boldsymbol{x}\|^2 = c^2dt'^2
\]</span></p>
<p>이며, 이로부터</p>
<p><span class="math display">\[
dt' = dt \sqrt{1-\dfrac{\|d\boldsymbol{x}\|^2}{c^2(dt)^2}}
\]</span></p>
<p>그런데</p>
<p><span class="math display">\[
\dfrac{\|d\boldsymbol{x}\|}{dt} = \dfrac{\sqrt{dx^2+dy^2+dz^2}}{dt} = v
\]</span></p>
<p>이므로</p>
<p><span class="math display">\[
dt' = dt\sqrt{1-\dfrac{v^2}{c^2}}
\]</span></p>
<p>이며, 이것을 기준틀 <span class="math inline">\(\Sigma\)</span> 의 시간에 대해 적분하면 시계에 고정된 기준틀에서의 시간 간격을 얻는다. 어떤 움직이는 물체에서 그 물체에 고정되어 움직이는 시계에서 측정한 시간 간격과 그 물체의 속도를 측정하는 기준틀에서의 시간 간격의 관계로 이 때 움직이는 물체의 시간 간격을 <strong>고유 시간</strong> (<em>proper time</em>) 이라고 하며 <span class="math inline">\(\Delta \tau\)</span> 로 표기한다.</p>
<p><span id="eq-CFT-proper_time"><span class="math display">\[
\Delta \tau : = t'_2-t'_1 = \int_{t_1}^{t_2} \sqrt{1-\dfrac{v^2}{c^2}} \, dt.
\tag{1.4}\]</span></span></p>
<p><span class="math inline">\(v \le c\)</span> 이므로 <span class="math inline">\(\Delta \tau = t'_2-t'_1 \le t_2-t_1\)</span> 임을 안다. 즉 움직이는 기준틀에서의 시간 간격은 정지된 기준틀에서의 시간 간격보다 항상 작다.</p>
<p><br></p>
</section>
<section id="sec-CFT_proper_time_in_different_frame" class="level3" data-number="1.3.2">
<h3 data-number="1.3.2" class="anchored" data-anchor-id="sec-CFT_proper_time_in_different_frame"><span class="header-section-number">1.3.2</span> 두 좌표계의 고유시간</h3>
<p>… to be fiiled…</p>
<p><br></p>
</section>
</section>
<section id="로런츠-변환" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="로런츠-변환"><span class="header-section-number">1.4</span> 로런츠 변환</h2>
<p>고전역학과는 달리 상대성 이론에서 보존하는 것은 거리가 아니라 시공간 간격이다. 4차원 시공간 간격을 보존하는 변환을 로런츠 변환이라고 한다. 두 기준틀 사이에 시공간 간격을 보존시키는 변환을 <strong>로런츠 변환 (Lorentz transformation)</strong> 이라고 한다.</p>
<p><br></p>
<section id="sec-CFT-lorentz_transform_in_1d_space" class="level3" data-number="1.4.1">
<h3 data-number="1.4.1" class="anchored" data-anchor-id="sec-CFT-lorentz_transform_in_1d_space"><span class="header-section-number">1.4.1</span> 1차원 공간에서의 로런츠 변환</h3>
<p>두 기준틀 <span class="math inline">\(\Sigma,\, \Sigma'\)</span> 에서 <span class="math inline">\(tx,\, tx'\)</span> 상에서만의 변환을 생각하자. 이 경우 원점과의 간격은 각각 <span class="math inline">\(ct^2-x^2,\, ct'^2-x'^2\)</span> 이다. 3차원 공간상에서 거리를 보존하는 변환을 회전 이라고 하듯이 4차원 시공간상에서 원점과의 간격을 거리로 생각하여 보존시키는 변환을 회전이라고 하기도 한다. 이 때</p>
<p><span id="eq-CFT_lorent_transform_in_1d_0"><span class="math display">\[
x = x' \cosh \psi + ct' \sinh \psi ,\qquad ct = x' \sinh \psi + ct' \cosh \psi
\tag{1.5}\]</span></span></p>
<p>일 경우 간격을 보존한다. 여기서 당연히 <span class="math inline">\(\psi\)</span> 는 두 기준틀의 상대속도 <span class="math inline">\(V\)</span> 의 함수이다.</p>
<p><span class="math inline">\(\Sigma'\)</span> 이 <span class="math inline">\(\Sigma\)</span> 에 대해 <span class="math inline">\(V\hat{\boldsymbol{x}}\)</span> 의 속도로 움직인다고 할 때 <span class="math inline">\(\Sigma'\)</span> 의 원점의 운동을 생각해보자. 즉 <span class="math inline">\(x'=0\)</span> 일 경우</p>
<p><span class="math display">\[
x=ct'\sinh \psi,\qquad ct = ct' \cosh \psi
\]</span></p>
<p>이며</p>
<p><span class="math display">\[
\dfrac{x}{ct}= \tanh \psi = \dfrac{V}{c}
\]</span></p>
<p>이다. 이로부터,</p>
<p><span class="math display">\[
\sinh \psi = \dfrac{V/c}{1-V^2/c^2},\qquad \cosh \psi = \dfrac{1}{\sqrt{1-V^2/c^2}}
\]</span></p>
<p>을 얻는다. 이를 <a href="#eq-CFT_lorent_transform_in_1d_0" class="quarto-xref">식&nbsp;<span>1.5</span></a> 에 대입하면 다음을 얻는다.</p>
<p><span id="eq-CFT_lorent_transform_in_1d"><span class="math display">\[
x = \dfrac{x'+Vt'}{\sqrt{1-V^2/c^2}},\quad y=y',\quad z=z',\quad t=\dfrac{t'+V/c^2 x'}{\sqrt{1-V^2/c^2}}.
\tag{1.6}\]</span></span></p>
<p><span class="math inline">\(c\to \infty\)</span> 극한에서 우리는 갈릴레이 변환을 얻는다는 것을 확인 할 수 있다. <span class="math inline">\(V&gt;c\)</span> 에서 <span class="math inline">\(x,\,t\)</span> 가 허수가 되는데 이는 물리적으로 무의미하며 따라서 속도 <span class="math inline">\(V\le c\)</span> 인 조건을 확인 할 수 있다.</p>
<p><br></p>
</section>
<section id="sec-CFT_proper_length_and_lorentz_contraction" class="level3" data-number="1.4.2">
<h3 data-number="1.4.2" class="anchored" data-anchor-id="sec-CFT_proper_length_and_lorentz_contraction"><span class="header-section-number">1.4.2</span> 고유길이와 로런츠 수축</h3>
<p>막대기가 <span class="math inline">\(\Sigma\)</span> 기준틀의 <span class="math inline">\(x\)</span> 축상에 위치한다고 하자. 이 때 그 길이 <span class="math inline">\(L=\Delta x = x_2-x_1\)</span> 이라고 하자. 앞서와 마찬가지로 <span class="math inline">\(\Sigma\)</span> 에 대해 <span class="math inline">\(V\hat{\boldsymbol{x}}\)</span> 의 속도로 움직이는 <span class="math inline">\(\Sigma'\)</span> 기준틀에서 <span class="math inline">\(t'\)</span> 일 때의 위치를 <span class="math inline">\(x'_1,\,x'_2\)</span> 라고 하면</p>
<p><span class="math display">\[
x_1 = \dfrac{x_1'+Vt'}{\sqrt{1-V^2/c^2}},\qquad x_2=\dfrac{x_2'+Vt'}{\sqrt{1-V^2/c^2}}
\]</span></p>
<p>이므로 <span class="math inline">\(L'=\Delta x' = x'_2-x'_1\)</span> 에 대해 다음을 얻는다.</p>
<p><span class="math display">\[
L = \dfrac{L'}{\sqrt{1-V^2/c^2}}&gt; L'
\]</span></p>
<p>즉 움직이는 기준틀에서의 길이는 정지된 좌표계에 비해 짧아지며 이를 <strong>로런츠 수축 (Lorentz contration)</strong> 이라고 한다. 그리고 정지된 좌표계에서 측정한 길이를 <strong>고유 길이 (proper length)</strong> 라고 한다.</p>
<p><br></p>
</section>
<section id="sec-CFT_proper_time_by_lorentz_transform" class="level3" data-number="1.4.3">
<h3 data-number="1.4.3" class="anchored" data-anchor-id="sec-CFT_proper_time_by_lorentz_transform"><span class="header-section-number">1.4.3</span> 로런츠 변환으로 본 고유시간</h3>
<p><a href="#eq-CFT_lorent_transform_in_1d" class="quarto-xref">식&nbsp;<span>1.6</span></a> 을 생각하자. 역시 정지된 <span class="math inline">\(\Sigma\)</span> 에 대해 <span class="math inline">\(V\hat{\boldsymbol{x}}\)</span> 의 속도로 움직이는 <span class="math inline">\(\Sigma'\)</span> 기준틀을 생각하자. 로런츠 변환에 의해</p>
<p><span class="math display">\[
t_1 = \dfrac{t_1' + Vx'/c^2}{\sqrt{1-V^2/c^2}},\qquad t_2 = \dfrac{t_2' + Vx'/c^2}{\sqrt{1-V^2-c^2}}
\]</span></p>
<p>이며, 따라서</p>
<p><span class="math display">\[
\Delta \tau = \Delta t'z = \Delta t {\sqrt{1-\dfrac{V^2}{c^2}}}
\]</span></p>
<p>이다.</p>
<p><br></p>
</section>
<section id="sec-CFT_lorentz_tranfrom_of_velocity" class="level3" data-number="1.4.4">
<h3 data-number="1.4.4" class="anchored" data-anchor-id="sec-CFT_lorentz_tranfrom_of_velocity"><span class="header-section-number">1.4.4</span> 속도의 로런츠 변환</h3>
<p>역시 정지된 <span class="math inline">\(\Sigma\)</span> 에 대해 <span class="math inline">\(V\hat{\boldsymbol{x}}\)</span> 의 속도로 움직이는 <span class="math inline">\(\Sigma'\)</span> 기준틀을 생각하자. <span class="math inline">\(\Sigma\)</span> 기준틀에서의 속도가 <span class="math inline">\(\Sigma'\)</span> 기준틀에서 어떻게 변화하는지 알아보자. <a href="#eq-CFT_lorent_transform_in_1d" class="quarto-xref">식&nbsp;<span>1.6</span></a> 로부터</p>
<p><span class="math display">\[
dx = \dfrac{dx'+Vdt'}{\sqrt{1-V^2/c^2}} ,\quad dy=dy',\quad dz=dz',\quad dt = \dfrac{dt'+Vdx'/c^2}{\sqrt{1-V^2/c^2}}
\]</span></p>
<p>이며 <span class="math inline">\(\boldsymbol{v}=\dfrac{d\boldsymbol{x}}{dt},\, \boldsymbol{v}'=\dfrac{d\boldsymbol{x}'}{dt'}\)</span> 을 구하면 다음을 얻는다.</p>
<p><span id="eq-CFT_lorentz_transform_of_velocity_along_x_axis"><span class="math display">\[
v_x = \dfrac{v_x' + V}{1+ v_x'\dfrac{V}{c^2}},\quad v_y = \dfrac{v_y'\sqrt{1-\dfrac{V^2}{c^2}}}{1+ v_x'\dfrac{V^2}{c^2}}\quad v_z = \dfrac{v_z'\sqrt{1-\dfrac{V^2}{c^2}}}{1+ v_x'\dfrac{V^2}{c^2}}
\tag{1.7}\]</span></span></p>
<p>역시 <span class="math inline">\(c\to \infty\)</span> 극한에서 <span class="math inline">\(v_x = v_x'+V,\, v_y=v_y',\, v_z=v_z'\)</span> 을 얻으며 이는 갈릴레이 변환과 동일하다.</p>
<p>이제 2차원 평면상의 운동을 생각하자. <span class="math inline">\(v_z=v'_z=0\)</span> 이며 <span class="math inline">\(x\)</span> 와 <span class="math inline">\(x'\)</span> 축에 대해 움직이는 각도 <span class="math inline">\(\theta,\,\theta'\)</span> 을 생각하면 <span class="math inline">\(v_x = v\cos \theta,\, v_y = v \sin \theta\)</span>, <span class="math inline">\(v'_x = v'\cos\theta',\, v'_y=v'\sin\theta\)</span> 이다. <a href="#eq-CFT_lorentz_transform_of_velocity_along_x_axis" class="quarto-xref">식&nbsp;<span>1.7</span></a> 로 부터</p>
<p><span id="eq-CFT-aberration_of_mass"><span class="math display">\[
\begin{aligned}
\tan \theta &amp;= \dfrac{v_y}{v_x} = \dfrac{v' \sin \theta' \sqrt{1-V^2/c^2}} {v'\cos \theta' + V}
\end{aligned}
\tag{1.8}\]</span></span></p>
<p>이다. 그런데 <span class="math inline">\(v'=c\)</span> 인 경우, 즉 빛인 경우</p>
<p><span id="eq-CFT-aberration_of_light"><span class="math display">\[
\tan\theta = \dfrac{\sqrt{1-V^2/c^2}}{\cos \theta' + V/c}
\tag{1.9}\]</span></span></p>
<p>를 얻는다. 이렇게 빛에 대해 기준틀에 따라 빛의 방향이 바뀌는 것을 <strong>광행차 (aberration of light)</strong> 라고 한다.</p>
<p><br></p>
</section>
</section>
<section id="수학적-기초" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="수학적-기초"><span class="header-section-number">1.5</span> 수학적 기초</h2>
<section id="sec-CFT_contravariant_covariant_einstein" class="level3" data-number="1.5.1">
<h3 data-number="1.5.1" class="anchored" data-anchor-id="sec-CFT_contravariant_covariant_einstein"><span class="header-section-number">1.5.1</span> 공변벡터, 반변벡터, 아인슈타인 표기법</h3>
<section id="공변벡터와-반변벡터" class="level4">
<h4 class="anchored" data-anchor-id="공변벡터와-반변벡터"><strong>공변벡터와 반변벡터</strong></h4>
<p>여기서는 유한차원 벡터공간 <span class="math inline">\(V\)</span> 와 그 쌍대공간 <span class="math inline">\(V^\ast\)</span> 에 대해 생각한다. <span class="math inline">\(V\)</span> 의 기저 <span class="math inline">\((e_1,\ldots,\,e_n)\)</span> 의 각각의 <span class="math inline">\(e_j\)</span> 에 대해 <span class="math inline">\(\theta^i\in V^\ast\)</span> 가 존재하여 <span class="math inline">\(\theta^i(e_j)=\delta^i_j\)</span> 이며, <span class="math inline">\((\theta^1,\ldots,\,\theta^n)\)</span> 이 <span class="math inline">\(V^\ast\)</span> 의 기저가 된다는 것을 안다. 이 때 <span class="math inline">\(\omega \in V^\ast\)</span> 를 <strong>공변벡터(covariant vector 혹은 covector)</strong> 라고 하고 <span class="math inline">\(v\in V\)</span> 를 <strong>반변 벡터(contravariant vector)</strong> 라고 한다.</p>
<p><br></p>
</section>
<section id="벡터의-성분값과-자연쌍대" class="level4">
<h4 class="anchored" data-anchor-id="벡터의-성분값과-자연쌍대"><strong>벡터의 성분값과 자연쌍대</strong></h4>
<p><span class="math inline">\(v\in V\)</span> 를 <span class="math inline">\(v=v^ie_i\)</span>, <span class="math inline">\(\omega \in V^\ast\)</span> 를 <span class="math inline">\(\omega = \omega_i \theta^i\)</span> 와 같이 표기하는 것이 표준적이다. 이 때 다음이 성립한다는 것을 알 수 있다. <span id="eq-CFT_componant_of_contravariant_and_covariant_vector"><span class="math display">\[
v^i = \theta^i(v),\qquad \omega_i = \omega(e_i).
\tag{1.10}\]</span></span></p>
<p><span class="math inline">\(\omega\in V^\ast,\, v\in V\)</span> 에 대해 <span class="math inline">\(\omega (v)\)</span> 가 존재한다. 이를 <strong>자연 쌍대(natural pairing)</strong> 이라고 한다. 이 때 다음이 성립한다.</p>
<p><span id="eq-CFT_natural_pariaing"><span class="math display">\[
\omega (v) =\sum_{i, j} \omega_i \theta^i(v^j e_j) = \sum_{i, j} \omega_iv^j \theta^i(e_j) = \underbrace{\sum_i \omega_iv^i \equiv \omega_i v^i}_{\text{Einstein notation}}
\tag{1.11}\]</span></span></p>
<p><a href="#eq-CFT_natural_pariaing" class="quarto-xref">식&nbsp;<span>1.11</span></a> 에서와 같이 <span class="math inline">\(\sum_i \omega_iv^i\)</span> 를 <span class="math inline">\(\omega_iv^i\)</span> 와 같이 표기하는 것을 <strong>아인슈타인 표기법 (Einsteine notation)</strong> 이라고 한다.</p>
<p><br></p>
</section>
</section>
<section id="sec-CFT_rule_of_transformation" class="level3" data-number="1.5.2">
<h3 data-number="1.5.2" class="anchored" data-anchor-id="sec-CFT_rule_of_transformation"><span class="header-section-number">1.5.2</span> 변환의 규칙</h3>
<p><span class="math inline">\(V\)</span> 의 기저를 <span class="math inline">\((e_1,\ldots,\,e_n)\)</span> 에서 <span class="math inline">\((e'_1,\ldots,\,e'_n)\)</span> 으로 변경한다고 하자. 이 때</p>
<p><span class="math display">\[
e'_i = {R_i}^j e_j
\]</span></p>
<p>라고 하면</p>
<p><span class="math display">\[
v=v^ie_i = v'^ie'_i=v'^i {R_i}^j e_j = {R_i}^jv'^i e_j
\]</span></p>
<p>이므로</p>
<p><span id="eq-CFT_transform_of_contavariant_vector_component"><span class="math display">\[
v'^i = ({R_i}^j)^{-1}v^j
\tag{1.12}\]</span></span></p>
<p>이어야 한다. 즉 <span class="math inline">\(v\in V\)</span> 의 성분은 기저의 변환에 대해 반대로(contra-) 변하므로(정확히는 역행렬에 따라 변하므로) 반변벡터라는 이름이 붙었다. 또한 이로부터</p>
<p><span class="math display">\[
\left({R_i}^j\right)^{-1} =  {\left(R^{-1}\right)^i}_j = \dfrac{\partial (x')^i}{\partial x^j},\qquad {R_i}^j = \dfrac{\partial x^j}{\partial (x')^i}
\]</span></p>
<p>임을 안다. 이에 반해</p>
<p><span id="eq-CFT_transform_of_covariant_vector_component"><span class="math display">\[
\omega'_i = \omega(e'_i)= {R_i}^j \omega(e_j)= {R_i}^j \omega_j
\tag{1.13}\]</span></span></p>
<p>이다. 즉 <span class="math inline">\(\omega\)</span> 의 성분은 기저의 변환에 대해 변환행렬에 맟추어(co-) 변하므로 공변벡터 라는 이름이 붙었다.</p>
<br>
<div class="border" style="background-color:#FFF0F5 ;padding:5px;">
<div id="prp-CFT_invairanice_of_scalar" class="theorem proposition">
<p><span class="theorem-title"><strong>명제 1.1</strong></span> <span class="math inline">\(v\in V,\, \omega\in V^\ast\)</span> 에서 <span class="math inline">\(v^i\omega_i\)</span> 는 좌표변환에 대해 불변이다.</p>
</div>
</div>
<div class="proof">
<p><span class="proof-title"><em>(증명)</em>. </span><span class="math inline">\(v'^i\omega'_i = ({R_i}^j)^{-1}v^j({R_i}^k)\omega_k = v^j\omega_j.\)</span></p>
</div>
<p><br></p>
</section>
<section id="텐서" class="level3" data-number="1.5.3">
<h3 data-number="1.5.3" class="anchored" data-anchor-id="텐서"><span class="header-section-number">1.5.3</span> 텐서</h3>
<section id="텐서와-변환규칙" class="level4">
<h4 class="anchored" data-anchor-id="텐서와-변환규칙"><strong>텐서와 변환규칙</strong></h4>
<p><span class="math inline">\(\mathbb{F}\)</span>-벡터공간 <span class="math inline">\(V_1,\,V_2,\ldots,\,V_k\)</span> 에 대해 <span class="math inline">\(V_1 \times \cdots \times V_k \mapsto \mathbb{R}\)</span> 함수이며 각각의 벡터공간에 대해 다중선형인 함수를 <span class="math inline">\(k\)</span>-차 <strong>텐서 (tensor)</strong> 라고 한다. 즉 <span class="math inline">\(v_i,\,u_i \in V_i\)</span> 와 <span class="math inline">\(c\in \mathbb{F}\)</span> 에 대해</p>
<p><span class="math display">\[
T(\ldots,\,v_i + cu_i,\ldots) = T(\ldots,v_i,\ldots) + c T(\ldots,u_i,\ldots)
\]</span></p>
<p>이어야 한다. 여기에서 다루는 텐서가 정의되는 벡터공간은 일반적으로 정해진 벡터공간 <span class="math inline">\(V\)</span> 에 대해 <span class="math inline">\(V\)</span> 이거나 <span class="math inline">\(V^\ast\)</span> 이다. <span class="math inline">\(V\)</span> 에 대해 정해진 기저 <span class="math inline">\((e_i)\)</span> 를 생각하자. <span class="math inline">\(T\)</span> 가 <span class="math inline">\(V\times V\)</span> 에서 정의된 텐서라면, 즉 2차 텐서라면</p>
<p><span class="math display">\[
T(u,\,v) = \sum_{i, j} u^iv^jT(e_i,\,e_j) \equiv T_{ij} u^iv^j
\]</span></p>
<p>이다. 우리는 <span class="math inline">\(T_{ij} := T(e_i,\,e_j)\)</span> 라고 정의 할 수 있다. 반대로 <span class="math inline">\(S\)</span> 가 <span class="math inline">\(V^\ast \times V^\ast\)</span> 에서 정의된 2차 텐서라면</p>
<p><span class="math display">\[
S(\omega,\, \eta) = \sum \omega_i \eta_j S(\theta^i,\, \theta^j) \equiv  S^{ij}\omega_i \eta_j
\]</span></p>
<p>이다. 우리는 <span class="math inline">\(S^{ij} = S(\theta^i,\,\theta^j)\)</span> 라고 정의 할 수 있다. 만약 <span class="math inline">\(A\)</span> 가 <span class="math inline">\(V \times V^\ast\)</span> 에서 정의된 텐서라면</p>
<p><span class="math display">\[
A(v,\,\omega) = \sum_{i,j} v^i\omega_j A(e_i,\,\theta^j) \equiv {A_i}^j v^i\omega_j
\]</span></p>
<p>이다. 우리는 <span class="math inline">\({A_i}^j\)</span> 를 <span class="math inline">\(A(e_i,\,\theta^j)\)</span> 로 정의 할 수 있다. 또한 이것을 확장하여 임의의 <span class="math inline">\(k\)</span> 차 텐서에 대해서도 텐서의 위첨자-아래첨자 표기법을 사용 할 수 있다. <span id="eq-CFT-transform_of_rank_2_tensor"><span class="math display">\[
\begin{aligned}
T'_{ij} &amp;:= T(e'_i,\,e'_j) = \sum_{k,\,l}T({R_i}^k e_k,\, {R_j^l} e_l) = {R_i}^k {R_j}^l T_{kl} , \\[0.3em]
S'^{ij} &amp;:= S(\theta'_i,\, \theta'_j) = \sum_{k,\,l}S\left(({R_i}^k)^{-1}\theta_k, ({R_j}^l)^{-1}\theta_l\right) = ({R_i}^k)^{-1}({R_j}^l)^{-1}\theta_l S^{kl}, \\[0.3em]
{{A'}_i}^j &amp;= A(e'_i,\,\theta'^j) = {R_i}^k({R_j}^l)^{-1} {A_k}^l.
\end{aligned}
\tag{1.14}\]</span></span></p>
<p>이 식을 보면 알 수 있듯이 이것은 2차 이상의 텐서에 대해서도 그대로 적용된다. 텐서의 공변 성분은 공변벡터의 변환을 따르고 반변 성분은 반번 벡터의 변환을 따른다.</p>
<p><br></p>
</section>
<section id="계량-텐서" class="level4">
<h4 class="anchored" data-anchor-id="계량-텐서"><strong>계량 텐서</strong></h4>
<p><span class="math inline">\(\mathbb{F}\)</span>-벡터공간 <span class="math inline">\(V\)</span> 에 대해, 정확히는 다양체 <span class="math inline">\(M\)</span> 의 탄젠트 공간 <span class="math inline">\(V=T_pM\)</span> 에서 정의되는 <strong>계량 텐서 (metric tensor)</strong> <span class="math inline">\(g \in \mathcal{T}^2(V)\)</span> 는 다음의 성질을 가진다.</p>
<p> (<span class="math inline">\(1\)</span>) <strong>대칭성</strong> : <span class="math inline">\(g(u,\,v) = g (v,\,u)\)</span>,</p>
<p> (<span class="math inline">\(2\)</span>) <strong>비축퇴성</strong> : <span class="math inline">\(\forall u\in V,\, g(v,\,u)=0 \iff v=0\)</span></p>
<p>계량텐서는 내적벡터공간의 내적과 같이 벡터공간에 부여되는 구조이다. 이 때 계량텐서가 <span class="math inline">\(0\)</span> 이 아닌 모든 <span class="math inline">\(u,\,v\in V\)</span> 에 대해 <span class="math inline">\(g(u,\,v) &gt; 0\)</span> 이면 이 텐서를 <strong>리만 계량(Riemann metric)</strong> 이라고 하고 아래와 같이 주어졌을 때 <strong>로런츠 계량(Lorentz metric)</strong> 이라고 한다. 텐서의 인덱스 규칙에 따라 <span class="math inline">\(g_{ij} = g(e_i,\,e_j)\)</span> 라고 하자. 로런츠 계량은 아래와 같이 주어진다.</p>
<p><span id="eq-CFT_lorentz_metric"><span class="math display">\[
g_{ij} = \left[\,\begin{array}{rrrr} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; -1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp;-1\end{array}\,\right].
\tag{1.15}\]</span></span></p>
<p>이 때 내림 사상 <span class="math inline">\(\flat : V\to V^\ast\)</span> 을 다음과 같이 정의한다.</p>
<p><span id="eq-CFT_flat_map"><span class="math display">\[
\flat(v) (u) := g(v,\,u).
\tag{1.16}\]</span></span></p>
<p><span class="math inline">\(g\)</span> 가 쌍선형 사상이므로 <span class="math inline">\(\flat\)</span> 은 선형사상이며 <span class="math inline">\(g\)</span> 의 비축퇴성으로 인해 <span class="math inline">\(\flat\)</span> 은 가역사상이다.</p>
<p>이 때, <span class="math inline">\(v=v^ie_i,\, u=u^je_j\)</span> 에 대해 <span class="math display">\[
\flat (v^ie_i)(u^ie_i) = g(v^ie_i,\, u^je_j) = \sum_{i,j}v^iu^jg(e_i,\,e_j) = g_{ij}v^iu^j
\]</span></p>
<p>이므로 <span class="math inline">\(v_j = g_{ij}v^i\)</span> 로 놓으면 <span class="math inline">\(g(v,\,u) = v_ju^j\)</span> 이다.</p>
<p><span class="math inline">\(\flat\)</span> 이 가역사상이므로 <span class="math inline">\(\flat\)</span> 의 역사상이 존재한다. 이를 <span class="math inline">\(\sharp\)</span> 라고 하자. 그렇다면 <span class="math inline">\(v^j = (g_{ij})^{-1}v_i\)</span> 이며 <span class="math inline">\((g_{ij})^{-1}\)</span> 은 아래 인덱스를 위 인덱스로 바꾸저 주는 역할을 하므로 <span class="math inline">\(g^{ij}\)</span> 와 같이 쓸 수 있다. 즉</p>
<p><span class="math display">\[
g^{ij} = (g_{ij})^{-1}
\]</span></p>
<p>이다.</p>
<p><br></p>
</section>
</section>
</section>
<section id="벡터" class="level2" data-number="1.6">
<h2 data-number="1.6" class="anchored" data-anchor-id="벡터"><span class="header-section-number">1.6</span> 4-벡터</h2>
<section id="sec-CFT_4_vector" class="level3" data-number="1.6.1">
<h3 data-number="1.6.1" class="anchored" data-anchor-id="sec-CFT_4_vector"><span class="header-section-number">1.6.1</span> 4-벡터와 4-스칼라</h3>
<p>사건 <span class="math inline">\((ct,\,x,\,y,\,z)\)</span> 는 4차원 시공간에서의 반경 벡터(radius vector)로 생각 할 수 있다. 이 벡터를 기술하는데</p>
<p><span class="math display">\[
x^0=ct,\quad x^1=x,\quad x^2=y,\quad x^3=z
\]</span></p>
<p>로 놓고 <span class="math inline">\(X=(x^0,\,x^1,\,x^2,\,x^3)\)</span> 와 같이 표기하도록 하자. 그리고 이 4 벡터의 제곱크기 <span class="math inline">\(\|X\|^2\)</span> 는 아래와 같이 정한다.</p>
<p><span class="math display">\[
\|X\|^2 = \left(x^0\right)^2 - \left(x^1\right)^2 -\left(x^2\right)^2 - \left(x^3\right)^2.
\]</span></p>
<p>이 길이는 로런츠 변환에 대해 불변이다. 이것은 앞서 4차원 시공간에 로런츠 계량 <span class="math inline">\(g\)</span>(<a href="#eq-CFT_lorentz_metric" class="quarto-xref">식&nbsp;<span>1.15</span></a>) 을 부여했을 때의 결과와 같다. 즉</p>
<p><span class="math display">\[
\|X\|^2=g_{ij}x^ix^j
\]</span></p>
<p>이다. 이렇게 반경 4-벡터와 같이 변환되는 4 값으로 구성된 튜플 <span class="math inline">\(A=(A^0,\,A^1,\,A^2,\,A^3)\)</span> 혹은 <span class="math inline">\(A=\begin{bmatrix} A^0 &amp;A^1 &amp; A^2 &amp; A^3\end{bmatrix}^T\)</span> 를 <strong>4-벡터</strong> 라고 하며 <span class="math inline">\(A^0\)</span> 를 시간 성분, 그리고 <span class="math inline">\(A^1,\,A^2,\,A^3\)</span> 를 공간성분이라고 한다. <span class="math inline">\(A=(A^0,\, \boldsymbol{A})\)</span> 와 같이 표기하기도 한다. 3차원 공간상의 벡터는 <span class="math inline">\(\boldsymbol{x}\)</span> 와 같이 표기하고 4-벡터는 그렇지 않다. 4-벡터 <span class="math inline">\(A=(A^0,\,A^1,\,A^2,\,A^3)=(A^0,\,\boldsymbol{A})\)</span> 의 제곱크기는 시공간 4-벡터와 마찬가지로 음의 값도, <span class="math inline">\(0\)</span> 도 될 수 있으며, 마찬가지로 시간꼴, 공간꼴 벡터를 말할 수 있다.</p>
<p><span class="math inline">\(\Sigma\)</span> 기준틀에 대해 <span class="math inline">\(\Sigma\)</span> 기준틀이 <span class="math inline">\(V\)</span> 의 속력으로 움직일 때 <span class="math inline">\(\beta,\,\gamma\)</span> 값을 아래와 같이 정하자.</p>
<p><span id="eq-CFT-definition_of_beta_and_gamma"><span class="math display">\[
\beta := \dfrac{V}{c},\qquad \gamma := \dfrac{1}{\sqrt{1-V^2/c^2}} = \dfrac{1}{\sqrt{1-\beta^2}}
\tag{1.17}\]</span></span></p>
<p><span class="math inline">\(V\)</span> 가 <span class="math inline">\(x\)</span> 축 방향일 때 4-벡터의 로런츠 변환은 아래와 같다.</p>
<p><span id="eq-CFT-lorentz_transform_of_contravariant_vector"><span class="math display">\[
A^0 = \gamma (A'^0 + \beta A'^1),\quad A^1 = \gamma (A'^1+ \beta A'^0),\quad A^2 = A'^2 ,\quad A^3 = A'^3.
\tag{1.18}\]</span></span></p>
<p>로런츠 계량을 이용하여 공변벡터의 로런츠 변환을 구하면 아래와 같다.</p>
<p><span id="eq-CFT-lorentz_transform_of_covariant_vector"><span class="math display">\[
A_0= \gamma (A'_0 - \beta A'_1),\quad A_1 = \gamma (A'_1- \beta A'_0),\quad A_2 = A'_2 ,\quad A_3 = A'_3.
\tag{1.19}\]</span></span></p>
<p><span class="math inline">\(A^iB_i =g_{ij}A^iB^j\)</span> 는 두 4-벡터의 곱으로 정의되는 스칼라량으로 <strong>4-스칼라</strong> 라고 불린다. <a href="#eq-CFT-lorentz_transform_of_contravariant_vector" class="quarto-xref">식&nbsp;<span>1.18</span></a> 와 <a href="#eq-CFT-lorentz_transform_of_covariant_vector" class="quarto-xref">식&nbsp;<span>1.19</span></a> 로부터 4-스칼라가 로런츠 변환에 대해 불변임을 보일 수 있다.</p>
<p><span class="math display">\[
\begin{aligned}
A^iB_i &amp;= \gamma^2 (A'^0+\beta A'^1)(A'_0 - \beta A'_1) + \gamma^2(A'^1+\beta A'^0)(A'_1 - \beta A'_0) + A'^2A'_2 + A'^3A'_3 \\[0.3em]
&amp;= \gamma^2 (1-\beta^2)A'_0 A'_0 + \gamma^2 (1-\beta^2)A'^1A'_1 + A'^2A'_2 + A'^3A'_3 = A'^iA'_i
\end{aligned}
\]</span></p>
<p>이 불변성은 모든 로런츠 변환에 대해 성립한다.</p>
<p><br></p>
</section>
<section id="sec-CFT_4_tensor" class="level3" data-number="1.6.2">
<h3 data-number="1.6.2" class="anchored" data-anchor-id="sec-CFT_4_tensor"><span class="header-section-number">1.6.2</span> 4-텐서</h3>
<p>4차원 2차 텐서는 16 개의 값으로 이루어졌으며 <span class="math inline">\(0\le i,\,j\le 3\)</span> 에 대해 반변 텐서 <span class="math inline">\(A^{ij}\)</span>, 공변 텐서 <span class="math inline">\(B_{ij}\)</span>, 혼합 텐서 <span class="math inline">\({C^i}_j\)</span> 와 같이 표기한다. <span class="math inline">\({C^i}_j\)</span> 와 <span class="math inline">\({C_j}^i\)</span> 는 구별된다. 4차원 텐서에 대한 일반적인 인덱스 반전 규칙은 다음과 같다.</p>
<p><span class="math display">\[
\begin{gather}
A_{00} = A^{00},\quad A_{01}=-A^{01},\quad A_{11}=A^{11},\ldots,\\[0.3em]
{A_{0}}^0 = A^{00},\quad {A_0}^1 = A^{01},\quad {A_1}^0 = -A^{10},\quad {A_1}^1 = -A^{11},\ldots,.
\end{gather}
\]</span></p>
<p>이 규칙은 2차 이상의 4차원 텐서에도 그대로 적용된다. 즉 인덱스 <span class="math inline">\(0\)</span> 은 반전시키더라도 변화가 없지만 <span class="math inline">\(1,\,2,\,3\)</span> 은 하나 반전시킬 때마다 <span class="math inline">\(-1\)</span> 이 곱해진다.</p>
<p>텐서 <span class="math inline">\(A^{ij}=A^{ji}\)</span> 일 때 이 텐서를 <strong>대칭 텐서(symmetric tensor)</strong> 라고 하고 <span class="math inline">\(A^{ij} = - A^{ji}\)</span> 일 때 <strong>반대칭 탠서 (antisymmetric tensor)</strong> 라고 한다.</p>
<p><br></p>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-CFT_basic_properties_of_symmetric_and_antisymmetric_teensor" class="theorem example">
<p><span class="theorem-title"><strong>예제 1.1 (반대칭 텐서와 대칭 텐서)</strong></span> <br></p>
<p>(<span class="math inline">\(1\)</span>) <span class="math inline">\(A^{ij}\)</span> 가 반대칭 텐서라고 하자. <span class="math inline">\(A^{ii} = - A^{ii}\)</span> 이므로 <span class="math inline">\(A^{ii}=0\)</span> 이다.</p>
<p>(<span class="math inline">\(2\)</span>) <span class="math inline">\(B^{ij}\)</span> 가 대칭텐서라고 하자. <span class="math inline">\({B_i}^j ={B_j}^i\)</span> 이며 이 경우 <span class="math inline">\(B^i_j\)</span> 로 쓸 수 있다.</p>
</div>
</div>
<p><br></p>
<section id="텐서의-trace" class="level4">
<h4 class="anchored" data-anchor-id="텐서의-trace"><strong>텐서의 trace</strong></h4>
<p>텐서 <span class="math inline">\(A^{ij}\)</span> 에 대해 행렬과 같이 <strong>trace</strong> <span class="math inline">\(\operatorname{tr}(A^{ij})\)</span> 를 아래와 같이 정의한다.</p>
<p><span id="eq-CFT_definition_of_trace_of_rank_2_tensor"><span class="math display">\[
\operatorname{tr}(A^{ij}) = {A^i}_i = {A^0}_0 + {A^1}_1 + {A^2}_2 + {A^3}_3.
\tag{1.20}\]</span></span></p>
<p><br></p>
</section>
<section id="단위-텐서-unit-tensor" class="level4">
<h4 class="anchored" data-anchor-id="단위-텐서-unit-tensor"><strong>단위 텐서 (unit tensor)</strong></h4>
<p><span class="math inline">\(\delta^i_j\)</span> 는 아래와 같이 정의된다.</p>
<p><span id="eq-CFT_definition_of_unit_tensor"><span class="math display">\[
\delta_i^j = \left\{\begin{array}{ll} 1, \qquad&amp;\text{if } i = j,\\ 0. &amp;\text{if } i \ne j\end{array}\right.
\tag{1.21}\]</span></span></p>
<p>따라서 임의의 4-벡터 <span class="math inline">\(A^i\)</span> 에 대해</p>
<p><span class="math display">\[
\delta_i^j A^i = A^j
\]</span></p>
<p>이다.</p>
<p><br></p>
</section>
<section id="계량-텐서-1" class="level4">
<h4 class="anchored" data-anchor-id="계량-텐서-1"><strong>계량 텐서</strong></h4>
<p>단위 텐서에 대해 한 인덱스를 올리거나 내린 <span class="math inline">\(g_{ij}\)</span> 혹은 <span class="math inline">\(g^{ij}\)</span> 를 <strong>계량텐서 (metric tensor)</strong> 라고 한다. 행렬로 아래와 같다.</p>
<p><span id="eq-CFT_definition_of_metric_tensor"><span class="math display">\[
g_{ij} = g^{ij} = \left[\,\begin{array}{rrrr} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; -1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp;-1\end{array}\,\right].
\tag{1.22}\]</span></span></p>
<p>이로부터 다음을 얻는다.</p>
<p><span id="eq-CFT_index_shift_using_metric_tensor"><span class="math display">\[
g_{ij}A^j = A_j,\qquad g^{ij}A_i = A^j.
\tag{1.23}\]</span></span></p>
<p>또한 다음이 성립한다.</p>
<p><span id="eq-CFT_contraction_using_metric_tensor"><span class="math display">\[
A^iA_i = g_{ij}A^iA^j = g^{ij}A_iA_j.
\tag{1.24}\]</span></span></p>
<p><br></p>
</section>
<section id="완전-반대칭-4차-단위-텐서" class="level4">
<h4 class="anchored" data-anchor-id="완전-반대칭-4차-단위-텐서"><strong>완전 반대칭 4차 단위 텐서</strong></h4>
<p><span class="math inline">\(0\le i,j,k,l\le 3\)</span> 에 대해 4차 텐서 <span class="math inline">\(\varepsilon^{ijkl}\)</span> 은 <span class="math inline">\(i,\,j,\,k,\,l\)</span> 이 <span class="math inline">\(0,\,1,\,2,\,3\)</span> 의 짝순열 이면 <span class="math inline">\(1\)</span>, 홀순열이면 <span class="math inline">\(-1\)</span>, 그렇지 않으면 <span class="math inline">\(0\)</span> 값을 갖는 텐서이다. 그리고 4차 텐서의 인덱스 이동 규칙에 따라 <span class="math inline">\(\varepsilon_{ijkl}= - \varepsilon^{ijkl}\)</span> 이다.</p>
<p><br></p>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-CFT_basic_properties_of_completely_antisymmetric_4th_unit_tensor" class="theorem example">
<p><span class="theorem-title"><strong>예제 1.2 (완전 반대칭 4차 단위 텐서의 특징)</strong></span> <br></p>
<p><span class="math inline">\(\varepsilon^{ijkl}=\operatorname{sgn}(ijkl),\, \varepsilon_{pqrs} = -\operatorname{sgn}(pqrs)\)</span> 라고 놓을 수 있다.</p>
<p>(<span class="math inline">\(1\)</span>) <span class="math inline">\(\varepsilon_{ijkl}= - \varepsilon^{ijkl}\)</span> 이며 <span class="math inline">\(0\)</span> 이 아닌 가능한 조합이 <span class="math inline">\(4!=24\)</span> 이므로</p>
<p><span id="eq-CFT_basic_properties_of_CA4UT_1"><span class="math display">\[
\varepsilon^{ijkl}\varepsilon_{ijkl}=-24.
\tag{1.25}\]</span></span></p>
<p>(<span class="math inline">\(2\)</span>) <span class="math inline">\(\varepsilon^{ijkl}\varepsilon_{pjkl}\)</span> 를 생각하자. <span class="math inline">\(i=p\)</span> 이어야 하며 가능한 조합이 6개 이므로</p>
<p><span id="eq-CFT_basic_properties_of_CA4UT_2"><span class="math display">\[
\varepsilon^{ijkl}\varepsilon_{pjkl}=-6\delta^i_p
\tag{1.26}\]</span></span></p>
<p>(<span class="math inline">\(3\)</span>) <span class="math inline">\(\varepsilon^{ijkl}\varepsilon_{pqkl}\)</span> 를 생각하자. <span class="math inline">\(i=p,\, j=q\)</span> 일 때와 <span class="math inline">\(i=q,\,j=p\)</span> 일 경우가 각각 2가지 이다. <span class="math inline">\(i=p,\,j=q\)</span> 일경우의 곱은 <span class="math inline">\(-1\)</span> 이며, <span class="math inline">\(i=q,\, j=p\)</span> 일 경우 <span class="math inline">\(\varepsilon_{pqlm}=-\varepsilon_{qplm}\)</span> 이므로 곱은 <span class="math inline">\(1\)</span> 이다. 따라서</p>
<p><span id="eq-CFT_basic_properties_of_CA4UT_3"><span class="math display">\[
\varepsilon^{ijlm}\varepsilon_{pqlm}=-2\delta^i_p \delta^j_q + 2 \delta^i_q \delta^j_p.
\tag{1.27}\]</span></span></p>
<p>(<span class="math inline">\(4\)</span>) <span class="math inline">\(\varepsilon^{ijkl}\varepsilon_{pqrl}\)</span> 를 생각하자. <span class="math inline">\(i=p,\, j=q,\, k=r\)</span> 일 경우 곱은 <span class="math inline">\(-1\)</span> 이며 <span class="math inline">\(i=p,\, j=r,\, k=q\)</span> 인 경우 <span class="math inline">\(1\)</span> 이다. 이것을 6가지 경우 모두를 생각하면</p>
<p><span id="eq-CFT_basic_properties_of_CA4UT_4"><span class="math display">\[
\begin{aligned}
\varepsilon^{ijkl}\varepsilon_{pqrl} &amp;= - \delta^i_p\delta^j_q \delta^k_r + \delta^i_p\delta^j_r\delta^k_p + \delta^i_q\delta^j_p\delta^k_r - \delta^i_q\delta^j_r\delta^k_p - \delta^i_r\delta^j_p\delta^k_q + \delta^i_r\delta^j_q\delta^k_r \\[0.3em]
&amp;= - \det \left(\begin{bmatrix} \delta^i_p &amp; \delta^i_q &amp; \delta^i_r \\ \delta^j_p &amp; \delta^j_q &amp; \delta^j_r \\ \delta^k_p &amp; \delta^k_q &amp; \delta^k_r\end{bmatrix}\right).
\end{aligned}
\tag{1.28}\]</span></span></p>
<p>(<span class="math inline">\(5\)</span>) <span class="math inline">\(\varepsilon^{ijkl}\varepsilon_{pqrs}\)</span> 를 생각하자. (<span class="math inline">\(4\)</span>) 의 경우를 확장하면</p>
<p><span id="eq-CFT_basic_properties_of_CA4UT_5"><span class="math display">\[
\varepsilon^{ijkl}\varepsilon_{pqrs} = -\det \left(\begin{bmatrix} \delta^i_p &amp; \delta^i_q &amp; \delta^i_r &amp; \delta^i_s\\ \delta^j_p &amp; \delta^j_q &amp; \delta^j_r &amp; \delta^j_s\\ \delta^k_p &amp; \delta^k_q &amp; \delta^k_r &amp; \delta^k_s \\  \delta^l_p &amp; \delta^l_q &amp; \delta^l_r &amp; \delta^l_s\end{bmatrix}\right).
\tag{1.29}\]</span></span></p>
<p>(<span class="math inline">\(6\)</span>) <span class="math inline">\(\varepsilon^{pqrs}A_{ip}A_{jq}A_{kr}A_{ls}\)</span> 를 구해보자.</p>
<p><span class="math display">\[
\varepsilon^{pqrs}A_{ip}A_{jq}A_{kr}A_{ls} = \sum_{0\le p,q,r,s \le 3}\operatorname{sgn}(pqrs) A_{ip}A_{jq}A_{kr}A_{ls} \\[0.3em]
\]</span></p>
<p>이다. <span class="math inline">\((i,j,\,k,\,l)\)</span> 이 <span class="math inline">\((0,\,1,\,2,\,3)\)</span> 의 짝순열이면 위 식은 <span class="math inline">\(\det (A_{\alpha\beta})\)</span> 이지만 홀순열이면 <span class="math inline">\(-\det(A_{\alpha \beta})\)</span> 이다. 이로부터</p>
<p><span id="eq-CFT_basic_properties_of_CA4UT_6"><span class="math display">\[
\varepsilon^{pqrs}A_{ip}A_{jq}A_{kr}A_{ls} =\det (A_{\alpha\beta})\varepsilon^{ijkl} =  -\det (A_{\alpha\beta})\varepsilon_{ijkl}.
\tag{1.30}\]</span></span></p>
<p>(<span class="math inline">\(7\)</span>) <span class="math inline">\(\varepsilon^{ijkl}\varepsilon^{pqrs}A_{ip}A_{jq}A_{kr}A_{ls}\)</span> 를 구해보자. <a href="#eq-CFT_basic_properties_of_CA4UT_6" class="quarto-xref">식&nbsp;<span>1.30</span></a> 와 <a href="#eq-CFT_basic_properties_of_CA4UT_1" class="quarto-xref">식&nbsp;<span>1.25</span></a> 로 부터</p>
<p><span id="eq-CFT_basic_properties_of_CA4UT_7"><span class="math display">\[
\begin{aligned}
\varepsilon^{ijkl}&amp;\varepsilon^{pqrs}A_{ip}A_{jq}A_{kr}A_{ls} = \varepsilon^{ijkl}\varepsilon_{ijkl}\det (A_{\alpha\beta}) = 24 \det (A_{\alpha\beta}).
\end{aligned}
\tag{1.31}\]</span></span></p>
</div>
</div>
<p><br></p>
</section>
</section>
<section id="sec-CFT_psedoscala_and_pseudo_vector" class="level3" data-number="1.6.3">
<h3 data-number="1.6.3" class="anchored" data-anchor-id="sec-CFT_psedoscala_and_pseudo_vector"><span class="header-section-number">1.6.3</span> 유사스칼라와 유사벡터</h3>
<p>3차원 좌표계에서 원점 대칭 변환에 대해 그 부호가 일반적인 스칼라 혹은 벡터와 다를 때 이 스칼라와 벡터를 <strong>유사스칼라 (pseudo scalar)</strong>, <strong>유사벡터(pseudo vector)</strong> 라고 한다. 유사 벡터는 <strong>축벡터 (axial vector)</strong> 라고도 한다. 반면 읿반적인 벡터는 <strong>극벡터 (polar vector)</strong> 라고 한다. 3차원 공간에서 스칼라는 거울반사애 대해 부호가 바뀌지 않으며, 벡터는 부호가 바뀌지만 유사 스칼라는 부호가 바뀌며 유사벡터는 부호가 바뀌지 않는다. 대표적인 유사 스칼라는 세 벡터에 대해 <span class="math inline">\(\boldsymbol{a\cdot}(\boldsymbol{b}\times \boldsymbol{c})\)</span> 가 있으며 유사벡터는 각운동량 벡터 <span class="math inline">\(\boldsymbol{L}=\boldsymbol{r}\times \boldsymbol{v}\)</span> 가 있다. 극벡터와 축벡터의 내적으로 표현되는 스칼라는 유사스칼라이다.</p>
<p>스칼라는 0차 텐서, 벡터는 1차텐서이며 이것을 포괄적으로 텐서라고 하자. <span class="math inline">\(k\)</span>-차 텐서는 <span class="math inline">\(X\to X'\)</span> 좌표변환 <span class="math inline">\(R\)</span> 에 대해</p>
<p><span id="eq-CFT_coordinate_transform_of_rank_k_tensor"><span class="math display">\[
\begin{aligned}
(A')^{i_1,\ldots,i_k} &amp;= \dfrac{\partial (x')^{i_1}}{\partial x^{j_1}}\cdots \dfrac{\partial (x')^{i_k}}{\partial x^{j_k}} A^{j_1,\ldots,\,j_k}, \\[0.3em]
(A')_{i_1,\ldots,i_k} &amp;= \dfrac{\partial x^{j_1}}{\partial (x')^{i_1}}\cdots \dfrac{\partial x^{j_k}}{\partial (x')^{i_k}} A_{j_1,\ldots,\,j_k} \\[0.3em]
\end{aligned}
\tag{1.32}\]</span></span></p>
<p>와 같이 변환되며, 혼합텐서는 위의 두 식으로부터 변환을 유추 할 수 있다. 위의 변환을 <span class="math inline">\(A'=\Lambda(R) A\)</span> 라고 표현하자. 그러나 유사텐서는</p>
<p><span class="math display">\[
A' = \det (R) \Lambda (R) A
\]</span></p>
<p>와 같이 변환된다.</p>
<div class="border" style="background-color:#F2F4F4  ;padding:5px;">
<div id="exm-CFT_antisymmetric_4th_unit_tensor_is_pseudo_tensor" class="theorem example">
<p><span class="theorem-title"><strong>예제 1.3 (완전 반대칭 4차 단위 텐서는 유사텐서)</strong></span> 이제 <span class="math inline">\(\varepsilon^{ijkl}\)</span> 이 유사텐서임을 보이자. <span class="math inline">\({\Lambda^i}_p\)</span> 를 아래와 같이 정의한다.</p>
<p><span class="math display">\[
{\Lambda^{i}}_{p}:= \dfrac{\partial (x')^i}{\partial x^p}.
\]</span></p>
<p>그러</p>
</div>
</div>
<p><br></p>
</section>
<section id="sec-CFT_dual_tensor" class="level3" data-number="1.6.4">
<h3 data-number="1.6.4" class="anchored" data-anchor-id="sec-CFT_dual_tensor"><span class="header-section-number">1.6.4</span> 쌍대 텐서</h3>
<p><span class="math inline">\(A^{ij}\)</span> 가 반대칭 텐서 일 때 <span class="math inline">\(A^{ij}\)</span> 와 <span class="math inline">\(A^{\ast ij}:=\frac{1}{2} \varepsilon^{ijkl}A_{kl}\)</span> 은 서로에 대한 <strong>쌍대 텐서 (dual tensor)</strong> 라고 한다. 같은 방식으로 <span class="math inline">\(A^i\)</span> 에 대해 <span class="math inline">\(A^{\ast i} = \varepsilon^{ijkl}A_m\)</span> 은 쌍대 텐서이며, 미분기하학 용어로는 호지 쌍대(Hodge dual) 이다.</p>
<p>3차원 유클리드 공간에서 <span class="math inline">\(\boldsymbol{C}=\boldsymbol{A}\times \boldsymbol{B}\)</span> 일 때 <span class="math inline">\(C_{jk} = A_jB_k - A_kB_j\)</span> 에 대해 <span class="math inline">\(C_i =\dfrac{1}{2}\varepsilon_{ijk}C_{jk}\)</span> 이다. <span class="math inline">\(C_{jk}\)</span> 는 정의에 의해 반대칭 2차 텐서이며 3차원 유클리드 공간에서 <span class="math inline">\(C_{jk}\)</span> 와 <span class="math inline">\(C_i\)</span> 는 쌍대관계이다.</p>
<p>반대칭 4-텐서 <span class="math inline">\(A^{ij}\)</span> 는 아래의 형태를 갖는다.</p>
<p><span id="eq-CFT_matrix_representation_of_antisymmetric_tensor"><span class="math display">\[
\left[A^{ij}\right] = \left[\,\begin{array}{rrrr} 0 &amp; p_x &amp; p_y &amp; p_z \\ -p_x &amp; 0 &amp; -a_z &amp; a_y \\ -p_y &amp; a_z &amp; 0 &amp; -a_x \\ -p_z &amp; -a_y &amp; a_x &amp; 0\end{array} \,\right].
\tag{1.33}\]</span></span></p>
<p>위의 4-텐서 에서 <span class="math inline">\(p_x,\,p_y,\,p_z\)</span> 는 시간성분으로 공간의 변화에 대해 스칼라와 같이 변하는</p>
<p>이에 대해 텐서의 인덱스 규칙을 사용하면 공변텐서는 아래와 같다.</p>
<p><span id="eq-CFT_matrix_representation_of_antisymmetric_tensor"><span class="math display">\[
\left[A_{ij}\right] = \left[\,\begin{array}{rrrr} 0 &amp; -p_x &amp; -p_y &amp; -p_z \\ p_x &amp; 0 &amp; -a_z &amp; a_y \\ p_y &amp; a_z &amp; 0 &amp; -a_x \\ p_z &amp; -a_y &amp; a_x &amp; 0\end{array} \,\right].
\tag{1.34}\]</span></span></p>
<p>그렇다면,</p>
<p><span id="eq-CFT_matrix_representation_of_antisymmetric_tensor"><span class="math display">\[
\left[A^{\ast ij}\right] = \left[\,\begin{array}{rrrr} 0 &amp; -a_x &amp; -a_y &amp; -a_z \\ a_x &amp; 0 &amp; -p_z &amp; p_y \\ a_y &amp; p_z &amp; 0 &amp; -p_x \\ a_z &amp; -p_y &amp; p_x &amp; 0\end{array} \,\right].
\tag{1.35}\]</span></span></p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "복사완료!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "복사완료!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../src/ClassicalFieldTheory/00_index.html" class="pagination-link" aria-label="고전 장론">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">고전 장론</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../references.html" class="pagination-link" aria-label="References">
        <span class="nav-page-text">References</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>